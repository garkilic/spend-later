import SwiftUI
import PhotosUI

struct AddItemSheet: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var viewModel: AddItemViewModel
    @State private var photoPickerItem: PhotosPickerItem?
    @State private var showingCamera = false
    @State private var showingSourceChooser = false
    @State private var cameraError: String?
    @State private var showSaveSuccess = false
    @FocusState private var focusedField: Field?

    enum Field {
        case url
        case title
        case price
        case notes
        case tags
    }

    init(viewModel: AddItemViewModel) {
        _viewModel = StateObject(wrappedValue: viewModel)
    }

    var body: some View {
        NavigationStack {
            Form {
                // Photo section always at top
                photoSection
                    .id("photo-section") // Stable identity

                detailsSection
                    .id("details-section") // Stable identity

                if let error = viewModel.errorMessage {
                    Section {
                        Text(error)
                            .foregroundStyle(.red)
                    }
                }
            }
            .scrollDismissesKeyboard(.interactively)
            .navigationTitle("Record Impulse")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Close") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button {
                        Task { await save() }
                    } label: {
                        if showSaveSuccess {
                            Image(systemName: "checkmark")
                                .foregroundStyle(.green)
                                .fontWeight(.semibold)
                        } else if viewModel.isSaving {
                            ProgressView()
                        } else {
                            Text("Save")
                        }
                    }
                    .disabled(!viewModel.isValid || viewModel.isSaving)
                }

                // Done button for price field (decimal pad has no done button)
                if focusedField == .price {
                    ToolbarItemGroup(placement: .keyboard) {
                        Spacer()
                        Button("Done") {
                            viewModel.updatePriceFromText()
                            focusedField = nil
                        }
                        .fontWeight(.semibold)
                    }
                }
            }
            .fullScreenCover(isPresented: $showingCamera) {
                CameraView(onImageCaptured: { image in
                    viewModel.image = image
                }, onError: { error in
                    cameraError = error
                })
                .ignoresSafeArea()
            }
            .onChange(of: showingCamera) { _, isShowing in
                if isShowing {
                    // Dismiss keyboard before showing camera
                    focusedField = nil
                }
            }
            .onChange(of: showingSourceChooser) { _, isShowing in
                if isShowing {
                    // Dismiss keyboard before showing photo picker
                    focusedField = nil
                }
            }
            .alert("Camera Error", isPresented: Binding(
                get: { cameraError != nil },
                set: { if !$0 { cameraError = nil } }
            )) {
                Button("OK", role: .cancel) {
                    cameraError = nil
                }
                if cameraError?.contains("Settings") == true {
                    Button("Open Settings") {
                        if let settingsURL = URL(string: UIApplication.openSettingsURLString) {
                            UIApplication.shared.open(settingsURL)
                        }
                        cameraError = nil
                    }
                }
            } message: {
                if let error = cameraError {
                    Text(error)
                }
            }
            .sheet(isPresented: $showingSourceChooser) {
                PhotoSourcePickerView(
                    hasExistingPhoto: viewModel.image != nil,
                    photoPickerItem: $photoPickerItem,
                    onSelectCamera: { showingCamera = true },
                    onRemovePhoto: viewModel.image != nil ? { viewModel.image = nil } : nil
                )
                .presentationDetents([.medium, .large])
            }
            .onChange(of: photoPickerItem) { _, newItem in
                Task {
                    if let newItem = newItem {
                        do {
                            if let data = try await newItem.loadTransferable(type: Data.self),
                               let image = UIImage(data: data) {
                                await MainActor.run {
                                    viewModel.image = image
                                    photoPickerItem = nil
                                }
                            }
                        } catch {
                            await MainActor.run {
                                cameraError = "Failed to load image"
                                photoPickerItem = nil
                            }
                        }
                    }
                }
            }
            .onChange(of: focusedField) { oldValue, newValue in
                // Trigger preview when leaving URL field
                if oldValue == .url && newValue != .url {
                    viewModel.requestLinkPreview()
                }
            }
            .onAppear {
                // Auto-focus on title field when sheet opens
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.6) {
                    focusedField = .title
                }
            }
        }
    }
}

private extension AddItemSheet {
    @ViewBuilder
    var photoSection: some View {
        Section("Photo") {
            PhotoSectionContent(
                previewImage: viewModel.previewImage,
                userImage: viewModel.image,
                onTapPhoto: { showingSourceChooser = true }
            )
            .frame(maxWidth: .infinity)
        }
    }

    var detailsSection: some View {
        DetailsSectionContent(
            title: $viewModel.title,
            priceText: $viewModel.priceText,
            urlText: $viewModel.urlText,
            notes: $viewModel.notes,
            tagsText: $viewModel.tagsText,
            isFetchingPreview: viewModel.isFetchingPreview,
            focusedField: $focusedField,
            onPriceFieldExit: { viewModel.updatePriceFromText() },
            onURLSubmit: { viewModel.requestLinkPreview() }
        )
    }

    func save() async {
        // Dismiss keyboard before saving to prevent snapshot warning
        focusedField = nil

        let success = await viewModel.save()
        if success {
            // Show success animation briefly before dismissing
            withAnimation {
                showSaveSuccess = true
            }
            try? await Task.sleep(for: .milliseconds(300))
            dismiss()
        }
    }
}

// MARK: - Optimized Child Views

/// Isolated photo section - only re-renders when images change
private struct PhotoSectionContent: View, Equatable {
    let previewImage: UIImage?
    let userImage: UIImage?
    let onTapPhoto: () -> Void

    static func == (lhs: PhotoSectionContent, rhs: PhotoSectionContent) -> Bool {
        lhs.previewImage === rhs.previewImage && lhs.userImage === rhs.userImage
    }

    var body: some View {
        VStack(alignment: .center, spacing: 12) {
            if let preview = previewImage {
                PreviewImageView(image: preview)
                    .id(ObjectIdentifier(preview))
            } else {
                PhotoPreviewPlaceholder(userImage: userImage, onTap: onTapPhoto)
                    .id(userImage != nil ? ObjectIdentifier(userImage!) : nil)

                Text("Optional: attach a quick photo of what you resisted.")
                    .font(.footnote)
                    .foregroundStyle(.secondary)
                    .multilineTextAlignment(.center)
            }
        }
    }
}

/// Cached image view - prevents re-rendering from SwiftUI Image conversion
private struct PreviewImageView: View {
    let image: UIImage

    var body: some View {
        Image(uiImage: image)
            .resizable()
            .scaledToFill()
            .frame(height: 220)
            .frame(maxWidth: .infinity)
            .clipped()
            .clipShape(RoundedRectangle(cornerRadius: 16))
            .drawingGroup() // Flattens layer hierarchy for performance
    }
}

/// Camera placeholder - isolated from text field updates
private struct PhotoPreviewPlaceholder: View {
    let userImage: UIImage?
    let onTap: () -> Void
    @State private var isImageReady = false

    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 16)
                .strokeBorder(style: StrokeStyle(lineWidth: 1, dash: [6]))
                .foregroundStyle(Color.accentColor.opacity(0.6))
                .frame(height: 220)
                .overlay(alignment: .center) {
                    VStack(spacing: 8) {
                        Image(systemName: userImage == nil ? "camera" : "arrow.triangle.2.circlepath.camera")
                            .font(.system(size: 40, weight: .medium))
                        Text(userImage == nil ? "Tap to add a photo" : "Change photo")
                            .font(.headline)
                    }
                    .foregroundStyle(Color.accentColor)
                }

            if let image = userImage, isImageReady {
                Image(uiImage: image)
                    .resizable()
                    .scaledToFill()
                    .frame(height: 220)
                    .clipShape(RoundedRectangle(cornerRadius: 16))
                    .overlay(alignment: .bottomTrailing) {
                        Label("Edit", systemImage: "slider.horizontal.3")
                            .padding(10)
                            .background(.thinMaterial)
                            .clipShape(Capsule())
                            .offset(x: -12, y: -12)
                    }
                    .drawingGroup()
                    .transition(.opacity)
            }
        }
        .contentShape(Rectangle())
        .onTapGesture(perform: onTap)
        .accessibilityLabel(userImage == nil ? "Add a photo" : "Change photo")
        .accessibilityAddTraits(.isButton)
        .onChange(of: userImage) { _, newImage in
            withAnimation(.easeIn(duration: 0.15)) {
                isImageReady = newImage != nil
            }
        }
        .onAppear {
            isImageReady = userImage != nil
        }
    }
}

/// Isolated details section - uses Bindings to prevent unnecessary re-renders
private struct DetailsSectionContent: View {
    @Binding var title: String
    @Binding var priceText: String
    @Binding var urlText: String
    @Binding var notes: String
    @Binding var tagsText: String
    let isFetchingPreview: Bool

    @FocusState.Binding var focusedField: AddItemSheet.Field?
    let onPriceFieldExit: () -> Void
    let onURLSubmit: () -> Void

    var body: some View {
        Section {
            // Title field with icon (required)
            HStack(spacing: 12) {
                Image(systemName: "tag.fill")
                    .font(.system(size: 18))
                    .foregroundStyle(Color.accentFallback)
                    .frame(width: 28, height: 28)
                    .background(Color.accentFallback.opacity(0.12))
                    .clipShape(Circle())

                TextField("What did you resist? *", text: $title)
                    .focused($focusedField, equals: .title)
                    .textContentType(.name)
                    .submitLabel(.next)
                    .font(.body)
                    .onSubmit {
                        focusedField = .price
                    }
            }
            .padding(.vertical, 4)
            .id("title-field")

            // Price field with enhanced styling
            PriceInputRow(
                priceText: $priceText,
                focusedField: $focusedField,
                onExit: onPriceFieldExit
            )
            .id("price-field")

            // URL field with icon
            URLInputRow(
                urlText: $urlText,
                isFetchingPreview: isFetchingPreview,
                focusedField: $focusedField,
                onSubmit: onURLSubmit
            )
            .id("url-field")

            // Notes field with icon and better placeholder
            HStack(alignment: .top, spacing: 12) {
                Image(systemName: "note.text")
                    .font(.system(size: 18))
                    .foregroundStyle(Color.accentFallback)
                    .frame(width: 28, height: 28)
                    .background(Color.accentFallback.opacity(0.12))
                    .clipShape(Circle())
                    .padding(.top, 4)

                ZStack(alignment: .topLeading) {
                    if notes.isEmpty && focusedField != .notes {
                        Text("Why did you resist this? (optional)")
                            .foregroundStyle(.secondary)
                            .font(.body)
                            .padding(.top, 8)
                    }
                    TextField("", text: $notes, axis: .vertical)
                        .lineLimit(3...6)
                        .focused($focusedField, equals: .notes)
                        .font(.body)
                }
            }
            .padding(.vertical, 4)
            .id("notes-field")

            // Tags field with icon
            HStack(spacing: 12) {
                Image(systemName: "number")
                    .font(.system(size: 18))
                    .foregroundStyle(Color.accentFallback)
                    .frame(width: 28, height: 28)
                    .background(Color.accentFallback.opacity(0.12))
                    .clipShape(Circle())

                TextField("Tags (comma separated)", text: $tagsText)
                    .focused($focusedField, equals: .tags)
                    .font(.body)
            }
            .padding(.vertical, 4)
            .id("tags-field")
        } header: {
            HStack {
                Text("DETAILS")
                    .sectionHeaderStyle()
                Spacer()
            }
        }
    }
}

/// Price input row - isolated to prevent form-wide re-renders
private struct PriceInputRow: View {
    @Binding var priceText: String
    @FocusState.Binding var focusedField: AddItemSheet.Field?
    let onExit: () -> Void

    @State private var displayText: String = ""
    @State private var updateTask: Task<Void, Never>?

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: "dollarsign.circle.fill")
                .font(.system(size: 18))
                .foregroundStyle(Color.successFallback)
                .frame(width: 28, height: 28)
                .background(Color.successFallback.opacity(0.12))
                .clipShape(Circle())

            TextField("0.00 *", text: $displayText)
                .keyboardType(.decimalPad)
                .focused($focusedField, equals: .price)
                .font(.system(size: 20, weight: .semibold, design: .rounded))
                .foregroundStyle(Color.primaryFallback)
                .accessibilityLabel("Price in US dollars (required)")
                .onChange(of: displayText) { _, newValue in
                    // Format as user types (locally only)
                    let filtered = newValue.filter { "0123456789.".contains($0) }

                    // Prevent multiple decimal points
                    let components = filtered.components(separatedBy: ".")
                    let formatted: String
                    if components.count > 2 {
                        formatted = components[0] + "." + components[1...].joined()
                    } else if components.count == 2 {
                        // Limit to 2 decimal places
                        let decimals = String(components[1].prefix(2))
                        formatted = components[0] + "." + decimals
                    } else {
                        formatted = filtered
                    }

                    if formatted != displayText {
                        displayText = formatted
                    }

                    // Throttle binding updates to reduce re-renders
                    updateTask?.cancel()
                    updateTask = Task { @MainActor in
                        try? await Task.sleep(for: .milliseconds(100))
                        if !Task.isCancelled {
                            priceText = formatted
                        }
                    }
                }
                .onChange(of: focusedField) { _, newValue in
                    // Sync display text when field gains focus
                    if newValue == .price {
                        displayText = priceText
                    } else if newValue != .price {
                        // Update immediately on blur and trigger exit
                        updateTask?.cancel()
                        priceText = displayText
                        onExit()
                    }
                }
                .onAppear {
                    displayText = priceText
                }
        }
        .padding(.vertical, 4)
    }
}

/// URL input row - isolated to prevent affecting other fields
private struct URLInputRow: View {
    @Binding var urlText: String
    let isFetchingPreview: Bool
    @FocusState.Binding var focusedField: AddItemSheet.Field?
    let onSubmit: () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack(spacing: 12) {
                Image(systemName: "link.circle.fill")
                    .font(.system(size: 18))
                    .foregroundStyle(Color.accentFallback)
                    .frame(width: 28, height: 28)
                    .background(Color.accentFallback.opacity(0.12))
                    .clipShape(Circle())

                TextField("Product URL (optional)", text: $urlText)
                    .keyboardType(.URL)
                    .autocorrectionDisabled()
                    .textInputAutocapitalization(.never)
                    .focused($focusedField, equals: .url)
                    .submitLabel(.done)
                    .font(.body)
                    .onSubmit {
                        onSubmit()
                    }
            }
            .padding(.vertical, 4)

            if isFetchingPreview {
                HStack(spacing: 8) {
                    ProgressView()
                        .progressViewStyle(.circular)
                        .scaleEffect(0.7)
                    Text("Fetching previewâ€¦")
                        .font(.caption)
                        .foregroundStyle(Color.accentFallback)
                }
                .padding(.leading, 40)
            }
        }
    }
}

#if DEBUG && canImport(PreviewsMacros)
#Preview {
    let container = PreviewSupport.container
    return AddItemSheet(viewModel: AddItemViewModel(itemRepository: container.itemRepository))
}
#endif
